# layer generation + report assemblyfrom __future__ import annotations

import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional

from mitre_agentic.mcp_client import MitreMcpClient


def _safe_get(d: Any, *path: str, default: Any = None) -> Any:
    cur = d
    for p in path:
        if not isinstance(cur, dict) or p not in cur:
            return default
        cur = cur[p]
    return cur


def _now_iso() -> str:
    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")


def _score_for_technique(
    technique: Dict[str, Any],
) -> int:
    """
    We want to score techniques based on severity and tactical versatility.
    Returns 0-100 for gradient coloring.
    
    Scoring:
    - Base: 30
    - Per tactic: +10 (max +30)
    - Critical tactics: +20
    - High-risk techniques: +20
    """
    score = 30  # Base score
    
    # Factor 1: Number of tactics (versatility)
    tactics = technique.get("tactics", [])
    tactic_count = len(tactics) if isinstance(tactics, list) else 0
    score += min(tactic_count * 10, 30)  
    
    # Factor 2: Critical tactics
    critical_tactics = {
        "initial-access", "execution", "privilege-escalation",
        "defense-evasion", "credential-access"
    }
    
    for tactic_dict in tactics:
        if isinstance(tactic_dict, dict):
            tactic = tactic_dict.get("tactic", "").lower().replace(" ", "-")
            if tactic in critical_tactics:
                score += 20
                break  # Only count once
    
    # Factor 3: Known high-risk techniques
    tid = technique.get("id", "")
    high_risk_techniques = [
        "T1059",  # Command and Scripting Interpreter
        "T1055",  # Process Injection
        "T1053",  # Scheduled Task/Job
        "T1003",  # OS Credential Dumping
        "T1078",  # Valid Accounts
        "T1566",  # Phishing
        "T1190",  # Exploit Public-Facing Application
    ]
    
    # Check parent ID for sub-techniques
    parent_id = tid.split(".")[0]
    if parent_id in high_risk_techniques:
        score += 10
    
    return min(score, 100)


async def build_navigator_layer_from_techniques(
    client: MitreMcpClient,
    *,
    confirmed_techniques: List[Dict[str, Any]],
    domain: str = "enterprise",
    layer_name: str = "Incident Technique Coverage",
    description: str = "",
    include_comments: bool = True,
    include_links: bool = True,
) -> Dict[str, Any]:
    """
    Agent (Viz):
    Create an ATT&CK Navigator layer JSON from technique IDs.
    
    Key behaviors:
    - Creates one entry per technique-tactic combination
    - Uses parent technique IDs (T1059, not T1059.001)
    - Enables subtechniques via showSubtechniques flag
    - Relies on gradient for automatic color assignment
    """
    # Get ATT&CK version from MCP server
    stats_resp = await client.call_tool("get_data_stats", {})
    stats = _safe_get(stats_resp, "result", default={})
    
    attack_version = stats.get("version", "18")
    if isinstance(attack_version, str) and "." in attack_version:
        attack_version = attack_version.split(".")[0]
    
    # Create Navigator layer structure
    layer = {
        "name": layer_name,
        "versions": {
            "attack": str(attack_version),
            "navigator": "5.1.0",
            "layer": "4.5"
        },
        "domain": f"{domain}-attack",
        "description": description or f"Generated by mitre-agentic on {_now_iso()}",
        "filters": {
            "platforms": ["Windows", "Linux", "macOS"]
        },
        "sorting": 0,
        "layout": {
            "layout": "side",
            "aggregateFunction": "average",
            "showID": False,
            "showName": True,
            "showAggregateScores": False,
            "countUnscored": False
        },
        "hideDisabled": False,
        "techniques": [],
        "gradient": {
            "colors": [
                "#8ec843ff",  # Green (low: 0-33)
                "#ffe766ff",  # Yellow (medium: 34-66)
                "#ff6666ff"   # Red (high: 67-100)
            ],
            "minValue": 0,
            "maxValue": 100
        },
        "legendItems": [],
        "metadata": [],
        "links": [],
        "showTacticRowBackground": False,
        "tacticRowBackground": "#dddddd",
        "selectTechniquesAcrossTactics": True,
        "selectSubtechniquesWithParent": False
    }

    # metadata
    layer["metadata"].append({"name": "Generated", "value": _now_iso()})
    layer["metadata"].append({"name": "Domain", "value": domain})
    layer["metadata"].append({"name": "ATT&CK Version", "value": attack_version})

    # links
    if include_links:
        layer["links"].append({
            "label": "MITRE ATT&CK MCP Server",
            "url": "https://github.com/imouiche/complete-mitre-attack-mcp-server",
        })

    # Process techniques
    for t in confirmed_techniques:
        tid = t.get("id")
        if not tid:
            continue

        # Convert sub-technique to parent (T1059.001 → T1059)
        parent_tid = tid.split(".")[0]
        
        score = _score_for_technique(t)

        # Extract tactics
        tactics = t.get("tactics", [])
        tactic_names: List[str] = []
        
        for tactic_dict in tactics:
            if isinstance(tactic_dict, dict):
                tactic = tactic_dict.get("tactic")
                if isinstance(tactic, str):
                    # Convert "Execution" → "execution"
                    # Convert "Command And Control" → "command-and-control"
                    tactic_normalized = tactic.lower().replace(" ", "-")
                    tactic_names.append(tactic_normalized)

        # Default to execution if no tactics found
        if not tactic_names:
            tactic_names = ["execution"]

        # Create ONE entry per tactic
        for tactic in tactic_names:
            tech_entry = {
                "techniqueID": parent_tid,  # ← Use parent ID
                "tactic": tactic,
                "score": score,
                "color": "",  # ← Empty = use gradient
                "comment": "",
                "enabled": True,
                "metadata": [],
                "links": [],
                "showSubtechniques": True  # ← Show sub-techniques
            }

            # Add comment
            if include_comments:
                name = t.get("name", "")
                all_tactic_names = [tn.replace("-", " ").title() for tn in tactic_names]
                
                comment = f"{name}"
                if len(all_tactic_names) > 1:
                    comment += f" | Tactics: {', '.join(all_tactic_names)}"
                
                tech_entry["comment"] = comment[:240]

            layer["techniques"].append(tech_entry)

    return layer


def save_layer_json(layer: Dict[str, Any], out_path: str | Path) -> Path:
    """
    Helper: save layer dict to JSON file.
    """
    out_path = Path(out_path).expanduser()
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(json.dumps(layer, indent=2, ensure_ascii=False))
    return out_path
